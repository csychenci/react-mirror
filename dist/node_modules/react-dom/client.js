const FunctionComponent = 0; // 函数组件
const HostRoot = 3; // ReactDom.render(<App/>) 的根节点对应的 Fiber 节点类型
const HostComponent = 5; // <div> 对应的 Fiber 节点类型
const HostText = 6; // <div>123</div> --> 123 对应的 Fiber 节点类型

const NoFlags = 0b0000001;
const Placement = 0b0000010;
const Update = 0b0000100;
const ChildDeletion = 0b0001000;
const MutationMask = Placement | Update | ChildDeletion;

class FiberNode {
    type;
    tag;
    pendingProps;
    key;
    stateNode;
    return;
    sibling;
    child;
    index;
    ref;
    memoizedProps;
    memoizedState;
    alternate;
    flags;
    subtreeFlags;
    updateQueue;
    constructor(tag, pendingProps, key) {
        // 实例属性
        this.tag = tag;
        this.key = key;
        this.stateNode = null; // HostComponent: <div> Dom
        this.type = null; // FunctionComponent: Component () => {}
        // 构成树状结构
        this.return = null; // 指向父级 FiberNode
        this.sibling = null; // 指向右边兄弟 FiberNode
        this.child = null; // 指向子级 FiberNode
        this.index = 0; // 多个同级 fiber， 当前 fiber 在兄弟节点中的位置
        this.ref = null; // 指向 ref
        // 作为工作单元
        this.pendingProps = pendingProps; // 工作单元刚开始准备工作的时候的 props
        this.memoizedProps = null; // 工作单元完成工作后的时候的 props
        this.updateQueue = null;
        this.memoizedState = null;
        /**
         * 用于在 fiberNode 和另一个 fiberNode 之间切换
         * 比如说当前的 fiberNode 是 current，那么 alternate 就指向 workInProgress fiberNode
         * 比如说当前的 fiberNode 是 workInProgress，那么 alternate 就指向 current fiberNode
         */
        this.alternate = null;
        this.flags = NoFlags; // 副作用
        this.subtreeFlags = NoFlags; // 子树的副作用
    }
}
class FiberRootNode {
    container; // 对应的宿主环境的挂载的节点(window 下是 domElement)
    current; // 指向 hostRootFiber
    /**
     * 指向更新完成(递归完成)以后的 hostRootFiber
     */
    finishedWork;
    constructor(container, hostRootFiber) {
        this.container = container;
        this.current = hostRootFiber;
        hostRootFiber.stateNode = this;
        this.finishedWork = null;
    }
}
const createWorkInProgress = (current, pendingProps) => {
    let wip = current.alternate;
    if (wip === null) {
        // mount
        wip = new FiberNode(current.tag, pendingProps, current.key);
        wip.stateNode = current.stateNode;
        wip.alternate = current;
        current.alternate = wip;
    }
    else {
        // update
        wip.pendingProps = pendingProps;
        // 清除副作用
        wip.flags = NoFlags;
        wip.subtreeFlags = NoFlags;
    }
    wip.type = current.type;
    wip.updateQueue = current.updateQueue;
    wip.child = current.child;
    wip.memoizedProps = current.memoizedProps;
    wip.memoizedState = current.memoizedState;
    return wip;
};
function createFiberFromElement(element) {
    const { type, key, props } = element;
    let fiberTag = FunctionComponent;
    if (typeof type === 'string') {
        // 原生标签
        fiberTag = HostComponent;
    }
    else if (typeof type !== 'function' &&
        true) {
        console.warn('未定义的type', element);
    }
    const fiber = new FiberNode(fiberTag, props, key);
    fiber.type = type;
    return fiber;
}

const createUpdate = (action) => {
    return {
        action
    };
};
const createUpdateQueue = () => {
    return {
        shared: {
            pending: null
        }
    };
};
const enqueueUpdate = (updateQueue, update) => {
    updateQueue.shared.pending = update;
};
const processUpdateQueue = (baseState, pendingUpdate) => {
    const result = { memoizedState: baseState };
    if (pendingUpdate !== null) {
        const action = pendingUpdate.action;
        if (action instanceof Function) {
            result.memoizedState = action(baseState);
        }
        else {
            result.memoizedState = action;
        }
    }
    return result;
};

const supportSymbol = typeof Symbol === 'function' &&
    typeof Symbol.for === 'function';
// 如果支持Symbol，则使用Symbol.for来创建一个唯一的Symbol，否则使用一个固定的数字
const REACT_ELEMENT_TYPE = supportSymbol
    ? Symbol.for('react.element')
    : 0xeac7;

function ChildReconciler(shouldTrackSideEffects) {
    function reconcileSingleElement(returnFiber, currentFiber, element) {
        // 根据 element 创建 fiber
        const fiber = createFiberFromElement(element);
        fiber.return = returnFiber;
        return fiber;
    }
    function reconcileSingleTextNode(returnFiber, currentFiber, content) {
        const fiber = new FiberNode(HostText, { content }, null);
        fiber.return = returnFiber;
        return fiber;
    }
    function placeSingleChild(fiber) {
        if (shouldTrackSideEffects &&
            fiber.alternate === null) {
            // shouldTrackSideEffects： 应该追逐副作用
            // fiber.alternate === null： 当前是首屏渲染的情况
            fiber.flags = Placement;
        }
        return fiber;
    }
    return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
        if (typeof newChild === 'object' &&
            newChild !== null) {
            switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                default:
                    {
                        console.warn('未实现的reconcile类型', newChild);
                    }
                    break;
            }
        }
        if (typeof newChild === 'string' ||
            typeof newChild === 'number') {
            // 文本节点
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
        }
        {
            console.warn('未实现的reconcile类型', newChild);
        }
        return null;
    };
}
const reconcileChildFibers = ChildReconciler(true);
const mountChildFibers = ChildReconciler(false);

// 递归中的递阶段
const beginWork = (wip) => {
    // 比较，返回子 fiberNode
    switch (wip.tag) {
        case HostRoot:
            return updateHostRoot(wip);
        case HostComponent:
            return updateHostComponent(wip);
        case HostText:
            return null;
        default:
            {
                console.warn('beginWork未实现的类型');
            }
            break;
    }
    return null;
};
function updateHostRoot(wip) {
    const baseState = wip.memoizedState;
    const updateQueue = wip.updateQueue;
    const pending = updateQueue.shared.pending;
    updateQueue.shared.pending = null;
    // 计算完以后，update 就没有用了
    const { memoizedState } = processUpdateQueue(baseState, pending);
    wip.memoizedState = memoizedState;
    const nextChildren = wip.memoizedState;
    reconcileChildren(wip, nextChildren);
    return wip.child;
}
function updateHostComponent(wip) {
    const nextProps = wip.pendingProps;
    const nextChildren = nextProps.children;
    reconcileChildren(wip, nextChildren);
    return wip.child;
}
function reconcileChildren(wip, children) {
    const current = wip.alternate;
    if (current !== null) {
        // 更新流程/update
        wip.child = reconcileChildFibers(wip, current.child, children);
    }
    else {
        // 插入流程/mount，不需要追踪副作用
        wip.child = mountChildFibers(wip, null, children);
    }
}

const createInstance = (type) => {
    const element = document.createElement(type);
    return element;
};
const appendInitialChild = (parent, child) => {
    parent.appendChild(child);
};
const createTextInstance = (content) => {
    return document.createTextNode(content);
};

const completeWork = (wip) => {
    // 收集副作用
    const newProps = wip.pendingProps;
    const current = wip.alternate;
    switch (wip.tag) {
        case HostComponent:
            if (current !== null && wip.stateNode) ;
            else {
                // 1. 构建 DOM
                const instance = createInstance(wip.type);
                // 2. 将 DOM 插入到 DOM 树中
                appendAllChildren(instance, wip);
                wip.stateNode = instance;
            }
            bubbleProperties(wip);
            return null;
        case HostText:
            if (current !== null && wip.stateNode) ;
            else {
                // 1. 构建 DOM
                const instance = createTextInstance(newProps?.content);
                wip.stateNode = instance;
            }
            bubbleProperties(wip);
            return null;
        case HostRoot:
            bubbleProperties(wip);
            return null;
        default:
            {
                console.warn('未处理的completeWork', wip);
            }
            break;
    }
};
function appendAllChildren(parent, wip) {
    let node = wip.child;
    while (node !== null) {
        if (node?.tag === HostComponent ||
            node?.tag === HostText) {
            appendInitialChild(parent, node?.stateNode);
        }
        else if (node?.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
        }
        if (node === wip) {
            return;
        }
        while (node.sibling === null) {
            if (node.return === null ||
                node.return === wip) {
                return;
            }
            node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
    }
}
function bubbleProperties(wip) {
    let subtreeFlags = NoFlags;
    let child = wip.child;
    while (child !== null) {
        subtreeFlags |= child.subtreeFlags;
        subtreeFlags |= child.flags;
        child.return = wip;
        child = child.sibling;
    }
    wip.subtreeFlags = subtreeFlags;
}

let workInProgress = null;
function prepareFreshStack(root) {
    workInProgress = createWorkInProgress(root.current, {});
}
function scheduleUpdateOnFiber(fiber) {
    // 调度功能
    const root = markUpdateFromFiberToRoot(fiber);
    renderRoot(root);
}
function markUpdateFromFiberToRoot(fiber) {
    let node = fiber, parent = node.return;
    while (parent !== null) {
        // 普通的 fiberNode 节点
        node = parent;
        parent = node.return;
    }
    if (node.tag === HostRoot) {
        return node.stateNode;
    }
    return null;
}
function renderRoot(root) {
    // 初始化
    prepareFreshStack(root);
    do {
        try {
            workLoop();
            break;
        }
        catch (e) {
            {
                console.warn('workLoop发生错误', e);
            }
            workInProgress = null;
        }
    } while (true);
    const finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    // wip fiberNode 树以及树中的 flags，执行具体的dom操作
    commitRoot(root);
}
function commitRoot(root) {
    const finishedWork = root.finishedWork;
    if (finishedWork === null) {
        return;
    }
    {
        console.warn("commit 阶段开始", finishedWork);
    }
    // 重置
    root.finishedWork = null;
    // 判断是否存在3个子阶段需要执行的操作
    // 1. root 的 flags 与 root 的 subtreeFlags 是否包含 MutationMask，包含的话就存在这三个子阶段需要执行的操作
    const subtreeHasFlags = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
    const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
    if (subtreeHasFlags || rootHasEffect) {
        // beforeMutation
        // Mutation
        root.current = finishedWork;
        // layout
    }
    else {
        root.current = finishedWork;
    }
}
function workLoop() {
    while (workInProgress !== null) {
        performUnitOfWork(workInProgress);
    }
}
function performUnitOfWork(fiber) {
    const next = beginWork(fiber);
    fiber.memoizedProps = fiber.pendingProps;
    if (next === null) {
        completeUnitOfWork(fiber);
    }
    else {
        workInProgress = next;
    }
}
function completeUnitOfWork(fiber) {
    // 遍历兄弟节点
    let node = fiber;
    do {
        completeWork(node);
        const sibling = node.sibling;
        if (sibling !== null) {
            workInProgress = sibling;
            return;
        }
        node = node.return;
        workInProgress = node;
    } while (node !== null);
}

function createContainer(container) {
    const hostRootFiber = new FiberNode(HostRoot, {}, null);
    const root = new FiberRootNode(container, hostRootFiber);
    hostRootFiber.updateQueue = createUpdateQueue();
    return root;
}
function updateContainer(element, root) {
    const hostRootFiber = root.current;
    const update = createUpdate(element);
    enqueueUpdate(hostRootFiber.updateQueue, update);
    scheduleUpdateOnFiber(hostRootFiber);
    return element;
}

function createRoot(container) {
    const root = createContainer(container);
    return {
        render(element) {
            return updateContainer(element, root);
        },
    };
}

var ReactDOM = /*#__PURE__*/Object.freeze({
	__proto__: null,
	createRoot: createRoot
});

export { ReactDOM as default };
